%{

/* ------------------------------------------------------------------
   Initial code (copied verbatim to the output file)
   ------------------------------------------------------------------ */
   
/* Includes*/
#include <malloc.h>  // _alloca is used by the parser
#include <string.h>  // strcpy
  
 
/*Lexical analyzer type*/
//class IParser;
#include "IParser.h"

/*Hook Lexical analyzer to Parser*/
#define YYPARSE_PARAM Parser::IParser* parserInstance
#define YYLEX_PARAM   parserInstance
#define YYERR_PARAM   parserInstance

extern int getLexema(void* /*YYSTYPE* */, YYPARSE_PARAM);
int yyparse(YYPARSE_PARAM);


//Semantic processing functions
void AppendVertex(YYPARSE_PARAM);
void SetAttributes(YYPARSE_PARAM);
void AppendConnection(YYPARSE_PARAM);
void SetVertexName(YYPARSE_PARAM);
void StartSubgraph(YYPARSE_PARAM);
void EndSubgraph(YYPARSE_PARAM);


/*Lexical analyzing function (Generated by Flex)*/
/*See "Parser.l"*/
namespace
{
	int yylex(void /*YYSTYPE*/ *lvalp, YYPARSE_PARAM)
   {
      return getLexema(lvalp, parserInstance);
   }
}

// Some yacc (bison) defines
#define YYDEBUG 1	      // Generate debug code; needed for YYERROR_VERBOSE
#define YYERROR_VERBOSE // Give a more specific parse error message 

/* Forward references*/
void yyerror (char *msg, YYPARSE_PARAM);

%}


/* ------------------------------------------------------------------
   Yacc declarations
   ------------------------------------------------------------------ */

/* The structure for passing value between lexer and parser */

%union {
   char *stringValue;
   int intValue;
}
/* The structure for passing value between lexer and parser */
/* ------------------------------------------------------------------*/

%pure_parser

/*Terminal symbols*/
%token <value>	  CONNECTION
%token <intValue> ID
%token LBRACKET RBRACKET 
%token ATTRIBUTES_HEADER 
%token NODE_SEPARATOR


%%

/* ------------------------------------------------------------------*/
/* -------------------GRAMMAR RULES----------------------------------*/
Graph : 
	NodeList 
;

NodeList :	  
	/* empty */ 
	| 
	  Node
	  NodeList
;			


Node : 
	AbstractVertex
	OptionalAttributes		
	ConnectionList	
;

OptionalAttributes : 
	/*empty*/
	| 
	  ATTRIBUTES_HEADER
	  ID {SetAttributes(parserInstance);}/*Attributes*/
;
					 
ConnectionList :
	/*empty*/
	| 
	  CONNECTION {AppendConnection(parserInstance);}
	  ConnectionList
;

AbstractVertex :
	Subgraph | ConcreteVertex
;

Subgraph :
	{AppendVertex(parserInstance);} 
	LBRACKET {StartSubgraph(parserInstance);}
	Graph 
	RBRACKET {EndSubgraph(parserInstance);}
;

ConcreteVertex :
	NODE_SEPARATOR 	{AppendVertex(parserInstance);} 
	ID {SetVertexName(parserInstance);}
;

/* -------------------GRAMMAR RULES----------------------------------*/
/* ------------------------------------------------------------------*/
